# Online Store (C++ + PostgreSQL + libpqxx)

## 1. Описание задачи

Цель работы — разработка учебной системы интернет‑магазина с использованием **C++**, **PostgreSQL** и библиотеки **libpqxx**, демонстрирующей:

* объектно‑ориентированное проектирование (наследование, полиморфизм, композиция, агрегация);
* работу с транзакциями, хранимыми процедурами, функциями и триггерами PostgreSQL;
* аудит и логирование действий пользователей;
* использование умных указателей, STL‑алгоритмов и лямбда‑выражений.

Система поддерживает роли **Администратор**, **Менеджер** и **Покупатель**, каждая из которых имеет строго определённые права доступа.

---

## 2. Архитектура проекта

### 2.1 Структура репозитория

```
/online-store
├── src/            # Исходные файлы .cpp
├── include/        # Заголовочные файлы .h
├── sql/            # SQL-скрипты (таблицы, функции, процедуры, триггеры)
├── reports/        # CSV-отчёты
├── README.md
├── CMakeLists.txt
└── .gitignore
```

### 2.2 Классы и ООП

* **DatabaseConnection<T>** — шаблонный класс для работы с PostgreSQL через libpqxx
* **User** (абстрактный базовый класс)

  * `Admin`
  * `Manager`
  * `Customer`
* **Order** — заказ
* **OrderItem** — элемент заказа (композиция)
* **Payment** + **PaymentStrategy** — стратегия оплаты (Strategy pattern)

#### Принципы ООП

* **Наследование и полиморфизм**: User → Admin / Manager / Customer
* **Композиция**:

  * Order владеет OrderItem
  * Order владеет Payment (`std::unique_ptr`)
* **Агрегация**:

  * User хранит `std::vector<std::shared_ptr<Order>>`

---

## 3. Работа с базой данных

### 3.1 Таблицы

* `users`
* `products`
* `orders`
* `order_items`
* `order_status_history`
* `audit_log`

Все таблицы создаются скриптом `sql/tables.sql`.

### 3.2 Ограничения

* CHECK (price > 0)
* CHECK (stock_quantity >= 0)
* UNIQUE(email)
* FOREIGN KEY между таблицами

---

## 4. Хранимые процедуры, функции и триггеры

### 4.1 Процедуры

* **createOrder** — создание заказа и его элементов в транзакции
* **updateOrderStatus** — изменение статуса заказа с записью истории и аудита

### 4.2 Функции

* `getOrderStatus(order_id)`
* `getUserOrderCount()`
* `getTotalSpentByUser(user_id)`
* `canReturnOrder(order_id)`
* `getOrderStatusHistory(order_id)`
* `getAuditLogByUser(user_id)`
* `getAuditOrderReport()` — используется для CSV‑отчёта

### 4.3 Триггеры

* автоматическое обновление даты заказа при смене статуса
* пересчёт суммы заказов при изменении цены продукта
* аудит операций с `products`, `orders`, `users`

---

## 5. Умные указатели и STL

### 5.1 Умные указатели

* `std::unique_ptr`:

  * Payment
  * PaymentStrategy
* `std::shared_ptr`:

  * Order (агрегация в User)

### 5.2 STL и лямбда‑выражения

Используются:

* `std::find_if` — поиск заказа пользователя
* `std::copy_if` — фильтрация заказов по статусу
* `std::accumulate` — подсчёт суммы заказов
* лямбды — проверка прав доступа

---

## 6. Логика ролей и прав доступа

### Администратор

* управление товарами
* просмотр всех заказов
* изменение статусов заказов
* просмотр истории и журнала аудита
* формирование CSV‑отчёта

### Менеджер

* утверждение заказов
* обновление остатков товаров
* просмотр только своих заказов (`approved_by`)
* просмотр аудита только по заказам

### Покупатель

* создание и управление заказами
* оплата заказа (разные стратегии)
* возврат заказа при соблюдении правил
* просмотр истории **только своих заказов**

Проверка прав выполняется **на уровне бизнес‑логики** с использованием лямбда‑функций.

---

## 7. Аудит и история изменений

### 7.1 order_status_history

Автоматически фиксирует:

* старый и новый статус заказа
* дату изменения
* пользователя, выполнившего изменение

### 7.2 audit_log

Логируются события:

* insert/update/delete товаров
* создание, изменение и возврат заказов
* ошибки при выполнении операций

---

## 8. CSV‑отчёт «История заказов и действий пользователей»

### 8.1 Описание

Отчёт формируется на основе данных:

* orders
* order_status_history
* audit_log

Используется SQL‑функция `getAuditOrderReport()`.

### 8.2 Формирование отчёта

Отчёт доступен **только администратору** и сохраняется в файл:

```
/reports/audit_report.csv
```

Формирование выполняется из C++:

* SELECT * FROM getAuditOrderReport()
* запись результата в CSV

---

## 9. Сборка и запуск проекта

### 9.1 Требования

* C++17
* PostgreSQL
* libpqxx
* CMake

### 9.2 Сборка

```bash
mkdir build
cd build
cmake .. \
  -DPostgreSQL_INCLUDE_DIR=/opt/homebrew/opt/libpq/include \
  -DPostgreSQL_LIBRARY=/opt/homebrew/opt/libpq/lib/libpq.dylib
cmake --build .
```

### 9.3 Запуск

```bash
./online_store
```

---

## 10. Пример работы

* выбор роли пользователя
* выполнение операций согласно правам
* автоматическое логирование всех критических действий
* формирование CSV‑отчёта администратором

Проект полностью соответствует требованиям задания и демонстрирует комплексную работу C++‑приложения с PostgreSQL.

